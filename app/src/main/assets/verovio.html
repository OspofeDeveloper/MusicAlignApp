<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
          function paintChordUniform(chordElement, chordColor, accidColor) {
          chordElement.style.fill = chordColor;

          const allChordNotes = chordElement.querySelectorAll('.note');
          for (const note of allChordNotes) {
            paintNoteParts(note, chordColor, chordColor, accidColor, chordColor);
          }

          const stem = chordElement.querySelector('.stem');
          if (stem) {
            paintStem(stem, chordColor);
          }
        }

        function paintPolygon(beamElement, color) {
          const polygons = beamElement.querySelectorAll('polygon');
          for (const polygon of polygons) {
            polygon.style.fill = color;
          }
        }

        function setIdToBeamParts(beamElement, fixId) {
          elementsWithoutFixId.push(beamElement);
          const polygons = beamElement.querySelectorAll('polygon');
          for (const polygonElement of polygons) {
            polygonElement.setAttribute('fixId', globalCounter);
	        globalCounter = globalCounter + 1;
	        elementsWithoutFixId.push(polygonElement);
          }
        }

        function sendPolygonsId(beamElement, type) {
          const polygons = beamElement.querySelectorAll('polygon');
          for (const polygonElement of polygons) {
            if(polygonElement.getAttribute('fixId') === currentIndex) {
                Android.sendNextElementId(polygonElement.getAttribute('fixId'), type);
            }
          }
        }

        function setIdToNotePartsOfBeamParts(noteElement, fixId) {
          const notehead = noteElement.querySelector('.notehead');
          const stem = noteElement.querySelector('.stem');
          const accid = noteElement.querySelector('.accid');
          const dots = noteElement.querySelector('.dots');
          const notations = noteElement.querySelector('.notations');

          if (notehead) {
            notehead.setAttribute('fixId', fixId);
	        globalCounter = globalCounter + 1;
	        elementsWithoutFixId.push(notehead);
          }
          if (stem) {
            stem.setAttribute('fixId', fixId);
	        globalCounter = globalCounter + 1;
	        elementsWithoutFixId.push(stem);
          }
          if (accid) {
            accid.setAttribute('fixId', fixId);
	        globalCounter = globalCounter + 1;
	        elementsWithoutFixId.push(accid);
          }
          if (dots) {
            dots.setAttribute('fixId', fixId);
	        globalCounter = globalCounter + 1;
	        elementsWithoutFixId.push(dots);
          }
          if (notations) {
            notations.setAttribute('fixId', fixId);
	        globalCounter = globalCounter + 1;
	        elementsWithoutFixId.push(notations);
          }
        }

        function paintNoteParts(noteElement, noteheadColor, stemColor, accidColor, dotsColor) {
          const notehead = noteElement.querySelector('.notehead');
          const stem = noteElement.querySelector('.stem');
          const accid = noteElement.querySelector('.accid');
          const dots = noteElement.querySelector('.dots');
          const notations = noteElement.querySelector('.notations');

          if (notehead) {
            notehead.style.fill = noteheadColor;
          }
          if (stem) {
            paintStem(stem, stemColor);
          }
          if (accid) {
            accid.style.fill = accidColor;
          }
          if (dots) {
            dots.style.fill = dotsColor;
          }
          if (notations) {
            notations.style.fill = 'cyan';
          }
        }

        function paintStem(stemElement, stemColor) {
        const path = stemElement.querySelector('path');
            if (path) {
                path.style.stroke = stemColor;
                stemElement.style.fill = stemColor;
            }
        }

      // Definir las funciones fuera del bloque de DOMContentLoaded
        let globalCounter = 0;
        let elementsWithoutFixId = [];
        let notesWithoutFixId = [];
        let intervalId = null;
        let elements2 = null;
        let currentIndex = parseInt(Android.getLastElementId().split("_")[1]);
        let elementsIdsJson = Android.getListElements();
        let elementsIds = JSON.parse(elementsIdsJson);
        let packageId = Android.getFileId();
        let highestElement = Android.getHighestElementId();
        let highestElementIndex = highestElement.split("_")[1];

        function colorNextElementPlay(elements, index) {
            colorElements(elements[index], 'cyan');
        }

        function colorPreviousElementPlay(elements, index, color) {
            colorElements(elements[index], color);
        }

        function colorNextElement(elements, type) {
          if (currentIndex < elements.length) {

            let element1 = "0";
            let nextElement = "0";

            if(currentIndex == 0) {
                elements.forEach((element, index) => {
                    if(index == 0) {
                        element1 = element;
                    }
                    if(index == 1) {
                        nextElement = element;
                    }
                });
            } else {
                element1 = elements[currentIndex];
                nextElement = elements[currentIndex + 1];
            }

            if(type === "nextFromAlignment") {
                console.log("element", element1.getAttribute('fixId'));
                console.log("nextElement", elements[currentIndex + 1].getAttribute('fixId'));
                agregarElemento(element1.getAttribute('fixId'), nextElement.getAttribute('fixId'), type);
                colorElements(element1, 'green');
            } else {
                if(elementsIds.includes(element1.getAttribute('fixId'))) {
                    colorElements(element1, 'green');
                } else {
                    colorElements(element1, 'orange');
                }
            }

            //console.log(element.getAttribute('fixId'));

            currentIndex++;
            if (currentIndex < elements.length) {
                let currentElement = elements[currentIndex];
                //console.log(currentElement.getAttribute('fixId'));
                colorElements(currentElement, 'blue');
                if(type === "nextFromButton") {
                    if (currentElement.classList.contains('beam')) {
                      sendPolygonsId(currentElement, type);
                    } else {
                      Android.sendNextElementId(currentElement.getAttribute('fixId'), type);
                    }
                }
            }
          }
        }

        function colorPreviousElement(elements) {
          if (currentIndex > 0) {
            let elementBack = elements[currentIndex];

            if(elementsIds.includes(elementBack.getAttribute('fixId'))) {
                colorElements(elementBack, 'green');
            } else {
                colorElements(elementBack, 'orange');
            }

            currentIndex--;
            //.log(elements[currentIndex]);
            Android.sendNextElementId(elements[currentIndex].getAttribute('fixId'), "back");
            if (currentIndex >= 0) {
                let currentElement = elements[currentIndex];
                //console.log(currentElement.getAttribute('fixId'));
                colorElements(currentElement, 'blue');
            }
          }
        }

        function colorPreviousNotAligned(elements) {
            let element = elements[currentIndex];
            if (currentIndex > 0) {
                for (let i = currentIndex - 1; i >= 0; i--) {
                    element = elements[i];
                    if(elementsIds.includes(element.getAttribute('fixId'))) {

                    } else {
                        if(elementsIds.includes(elements[currentIndex].getAttribute('fixId'))) {
                            colorElements(elements[currentIndex], 'green');
                        } else {
                            colorElements(elements[currentIndex], 'orange');
                        }

                        currentIndex = i;
                        Android.sendNextElementId(element.getAttribute('fixId'), "notAligned");
                        colorElements(element, 'blue');
                        break;
                    }
                }
            }
        }

        function colorNextNotAligned(elements) {
            let element = elements[currentIndex];
            if (currentIndex < elements.length) {
                for (let i = currentIndex + 1; i < elements.length; i++) {
                    element = elements[i];
                    if(elementsIds.includes(element.getAttribute('fixId'))) {

                    } else {
                        if(elementsIds.includes(elements[currentIndex].getAttribute('fixId'))) {
                            colorElements(elements[currentIndex], 'green');
                        } else {
                            colorElements(elements[currentIndex], 'orange');
                        }

                        currentIndex = i;
                        Android.sendNextElementId(element.getAttribute('fixId'), "notAligned");
                        colorElements(element, 'blue');
                        break;
                    }
                }
            }
        }

        function colorElements(element, color) {
            //if(color == 'red') {
            //  console.log(element.getAttribute('class'));
		    //  console.log(element.getAttribute('fixId'));
            //}
<!--            console.log('currentIndex:', currentIndex);-->
<!--            console.log('highestIndex:', highestElementIndex);-->

            Android.sendLastElementId(elements2[currentIndex].getAttribute('fixId'));
            if(currentIndex >= highestElementIndex) {
                highestElementIndex = currentIndex;
            }

            Android.sendHighestElementId(elements2[highestElementIndex].getAttribute('fixId'));
            if(currentIndex >= elements2.length - 1) {
                Android.sendEndOfListReached(true);
            } else {
                Android.sendEndOfListReached(false);
            }


            if (element.classList.contains('chord')) {
              paintChordUniform(element, color, color);
            } else if (element.classList.contains('rest')) {
              element.style.fill = color;
            } else if (element.nodeName.toLowerCase() === 'polygon') {
              element.style.fill = color;
            } else if (element.classList.contains('notehead')) {
              element.style.fill = color;
            } else if (element.classList.contains('dots')) {
              element.style.fill = color;
            } else if (element.classList.contains('accid')) {
              element.style.fill = color;
            } else if (element.classList.contains('stem')) {
              paintStem(element, color);
            } else if (element.classList.contains('note')) {
              if (element.parentNode.classList.contains('chord') ||
                element.parentNode.classList.contains('beam')) {
              } else {
                paintNoteParts(element, color, color, color, color);
              }
            } else if (element.classList.contains('clef')) {
              element.style.fill = color;
            } else if (element.classList.contains('label')) {
              element.style.fill = color;
            } else if (element.classList.contains('keySig')) {
                element.style.fill = color;
            } else if (element.classList.contains('meterSig')) {
                element.style.fill = color;
            } else if (element.classList.contains('dynam')) {
                element.style.fill = color;
            } else if (element.classList.contains('dir')) {
                element.style.fill = color;
            } else if (element.classList.contains('slur')) {
                element.style.fill = color;
                element.querySelector('path').style.stroke = color;
            } else if (element.classList.contains('labelAbbr')) {
                element.style.fill = color;
            } else if (element.classList.contains('hairpin')) {
                element.querySelector('polyline').style.stroke = color;
            } else if (element.classList.contains('grpSym')) {
                element.style.fill = color;
                const paths = element.querySelectorAll('path');
                for (const path of paths) {
                    path.style.stroke = color;
                }
            }
        }

        function agregarElemento(elemento, nextElement, type) {
            elementsIds.push(elemento.toString());
            Android.sendAlignedElementId(elemento, nextElement, type);
        }

        function borrarElemento(elemento) {
            let fixId = elemento.getAttribute('fixId');
            let index = elementsIds.indexOf(fixId);

            if (index !== -1) {
                elementsIds.splice(index, 1);
            }
        }

        function borrarElementoPorContenido(contenido) {
            const indice = elementsIds.indexOf(contenido.toString());
            if (indice !== -1) {
                elementsIds.splice(indice, 1);
            } else {

            }
        }

        function loadFile(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.responseType = 'arraybuffer';

                xhr.onload = function() {
                    if (xhr.status === 200) {
                        resolve(xhr.response);
                    } else {
                        reject(new Error(`Failed to load ${url}: ${xhr.status}`));
                    }
                };

                xhr.onerror = function() {
                    reject(new Error(`Network error while fetching ${url}`));
                };

                xhr.send();
            });
        }

        document.addEventListener("DOMContentLoaded", (event) => {
    verovio.module.onRuntimeInitialized = async _ => {
        let tk = new verovio.toolkit();

        // Set zoom and page size
        let zoom = 70;
        let pageHeight = document.body.clientHeight * 100 / zoom;
        let pageWidth = document.body.clientWidth * 100 / zoom;

        const options = {
            scale: zoom,
            // Add an option to pass note@pname and note@oct as svg @data-*
            svgAdditionalAttribute: ["note@pname", "note@oct"]
        };
        tk.setOptions(options);

        // Obtener el archivo desde Android
        const filePath = Android.getMeiXml();
        console.log('hola, el nombre del fichero es: ', filePath);

        // Extraer la extensión del archivo
        const fileExtension = filePath.split('.').pop().split('?')[0].toLowerCase();
        console.log('hola, la extension es: ', fileExtension);

        fetch(filePath, {})
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                return response.arrayBuffer();
            })
            .then(data => {
                console.log('Archivo cargado correctamente');

                if (fileExtension === 'mxl') {
                    // Descomprimir el archivo .mxl usando JSZip
                    return JSZip.loadAsync(data)
                        .then(zip => {
                            // Buscar el archivo container.xml dentro del archivo .mxl
                            return zip.file('META-INF/container.xml').async('string').then(containerXml => ({ zip, containerXml }));
                        })
                        .then(({ zip, containerXml }) => {
                            console.log('Contenido del archivo container.xml:', containerXml);

                            // Parsear el archivo container.xml para obtener la ruta del archivo de partitura
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(containerXml, "application/xml");
                            const rootfile = xmlDoc.getElementsByTagName('rootfile')[0];
                            const scorePath = rootfile.getAttribute('full-path');

                            // Leer el archivo de partitura especificado en container.xml
                            return zip.file(scorePath).async('string');
                        });
                } else if (fileExtension === 'musicxml' || fileExtension === 'xml') {
                    // El archivo ya es un MusicXML, convertir el ArrayBuffer a cadena directamente
                    return new TextDecoder('utf-8').decode(data);
                } else {
                    throw new Error('Tipo de archivo no soportado: ' + fileExtension);
                }
            })
            .then(musicXml => {
                console.log('Contenido MusicXML extraído correctamente');
                console.log('Contenido del archivo MusicXML:', musicXml);

                // Procesar el contenido MusicXML con Verovio
                let svg;
                try {
                    svg = tk.renderData(musicXml, {});  // Usar formato correcto
                } catch (error) {
                    throw new Error('Error al procesar el archivo MusicXML con Verovio: ' + error.message);
                }

                document.getElementById("notation").innerHTML = svg;

                // Ahora puedes seleccionar y manipular los elementos SVG
                let elements = document.querySelectorAll('g.notehead, g.stem, g.dots, g.accid, g.rest, polygon, g.clef, g.label, g.keySig, g.meterSig, g.dynam, g.dir, g.slur, g.labelAbbr, g.hairpin, g.grpSym');
                Android.sendFinalElementNum(elements.length.toString());
                console.log("Número de elementos:", elements.length);

                elements.forEach((element, index) => {
                    let hasSameId = notesWithoutFixId.some(item => {
                        console.log('item id:', item.id);
                        console.log('element id:', element.id);
                        return item.id === element.id;
                    });

                    const fixId = `${packageId}_${globalCounter}`;
                    if (!hasSameId) {
                        if (element.classList.contains('beam')) {
                            setIdToBeamParts(element, fixId);
                        } else {
                            elementsWithoutFixId.push(element);
                            if (element.classList.contains('accid')) {
                                if (element.querySelectorAll('use') == null) {
                                    // Do nothing
                                } else {
                                    element.setAttribute('fixId', fixId);
                                }
                            } else {
                                element.setAttribute('fixId', fixId);
                            }
                            globalCounter = globalCounter + 1;
                            console.log(element.getAttribute('fixId'));
                        }
                    }
                });

                elements2 = Array.from(elements);

                initSystem();
                paintSavedIds(elements2);
            })
            .catch(error => {
                console.error('Error:', error);
            });
    };
});


        function paintSavedIds(elements2) {
            let paintedIds = []; // Lista para almacenar los fixIds de los elementos pintados de verde

         elementsIds.forEach(elementId => {
              elements2.forEach(element => {
                  if (element.getAttribute('fixId') === elementId) {
                      colorElements(element, 'green');
                      paintedIds.push(elementId); // Agregar el fixId del elemento pintado a la lista
                  }
              });
         });

         let unpaintedIds = []; // Lista para almacenar los fixIds no pintados de azul

         // Iterar sobre elements2 para encontrar los fixIds no pintados de azul
         elements2.forEach(element => {
              let elementId = element.getAttribute('fixId');
              if (!paintedIds.includes(elementId)) {
                  unpaintedIds.push(elementId.split("_")[1]); // Agregar el fixId no pintado a la lista
              }
         });

        unpaintedIds.forEach(element => {
              if (parseInt(element) <= highestElementIndex) {
<!--                  console.log('bucleInt', element);-->
<!--                  console.log('bucleInt', highestElementIndex);-->
                  colorElements(elements2[element], 'orange');
              }
         });

<!--          console.log(currentIndex);-->
          colorElements(elements2[currentIndex], 'blue');

        }

        let paintIndex = 0;
        let elementColors = [];
        function initStart() {
            paintIndex = currentIndex;
            elements2.forEach(element => {
                elementColors.push(element.style.fill);
            });

            colorNextElementPlay(elements2, paintIndex);
            paintIndex++;

            intervalId = setInterval(() => {
                if(paintIndex > 0) {
                    colorPreviousElementPlay(elements2, paintIndex - 1, elementColors[paintIndex - 1]);
                }
                colorNextElementPlay(elements2, paintIndex);
                paintIndex++;
                if(paintIndex >= elements2.length) {
                    clearInterval(intervalId);
                }
                Android.sendNextFromPlay(elements2[paintIndex-1].getAttribute('fixId'),"nextFromPlay");
                console.log("hola");
            }, 1500);
        }

        function initSystem() {
            console.log("Last element", elements2[currentIndex].getAttribute('fixId'));
            console.log("Next element", elements2[currentIndex].getAttribute('fixId'));
            Android.sendLastElementId(elements2[currentIndex].getAttribute('fixId'));
            Android.sendNextElementId(elements2[currentIndex].getAttribute('fixId'), "initSystem");
        }

<!--        function initStop() {-->
<!--            colorPreviousElementPlay(elements2, paintIndex-1, elementColors[paintIndex-1]);-->
<!--            clearInterval(intervalId);-->
<!--        }-->

        function initNextAlignment() {
            colorNextElement(elements2, "nextFromAlignment");
        }

        function initNext() {
            colorNextElement(elements2, "nextFromButton");
        }

        function initBack() {
            colorPreviousElement(elements2);
        }

        function initBackNotAligned() {
            colorPreviousNotAligned(elements2);
        }

        function initNextNotAligned() {
            colorNextNotAligned(elements2);
        }

        function prepareForRealignment() {
<!--            console.log(currentIndex);-->
            let elemento = elements2[currentIndex];
            borrarElemento(elemento);
        }

    </script>
    <script src="https://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js" defer></script>
</head>
<body>
<div id="notation"></div>
</body>
</html>

<!--    let paintedIds = []; // Lista para almacenar los fixIds de los elementos pintados de azul

         elementsIds.forEach(elementId => {
              elements2.forEach(element => {
                  if (element.getAttribute('fixId') === elementId) {
                      colorElements(element, 'blue');
                      paintedIds.push(elementId); // Agregar el fixId del elemento pintado a la lista
                  }
              });
         });

         let unpaintedIds = []; // Lista para almacenar los fixIds no pintados de azul

         // Iterar sobre elements2 para encontrar los fixIds no pintados de azul
         elements2.forEach(element => {
              let elementId = element.getAttribute('fixId');
              if (!paintedIds.includes(elementId)) {
                  unpaintedIds.push(elementId.split("_")[1]); // Agregar el fixId no pintado a la lista
              }
         });

          // Encontrar el fixId más pequeño de la lista de fixIds no pintados
          let smallestUnpaintedId = Math.min(...unpaintedIds);
          //console.log(parseInt(smallestUnpaintedId));


          currentIndex = smallestUnpaintedId;
          console.log(currentIndex);
          colorElements(elements2[currentIndex], 'cyan');-->

<!--
const key = document.querySelector('.key');
            key.style.fill = 'red';

            const time = document.querySelector('.time');
            time.style.fill = 'purple';

            const clef = document.querySelector('.clef');
            clef.style.fill = 'green';
-->

<!--
FUNCIONES PARA PINTAR LOS ELEMENTOS COMPUESTOS POR MAS ELEMENTOS (POR EJEMPLO LOS CHORD Y BEAM QUE
SON ELEMENTOS QUE ESTAN COMPUESTOS POR NOTES Y STEAM) -> COMO UN CONJUNTO, ALL DEL MISMO COLOR

############## BEAM Uniform ##############
function paintBeamUniform(beamElement, beamColor) {
    beamElement.style.fill = beamColor;

    const allBeamStems = beamElement.querySelectorAll('.stem');
    for (stem of allBeamStems) {
        if (stem) {
          paintStem(stem, beamColor);
        }
    }
}

const allBeams = document.querySelectorAll('g.beam');
for (const beam of allBeams) {
  console.log(beam);
  paintBeamUniform(beam, 'red')
}
###########################################

############## BEAM Separating Elements ##############
function paintBeamSeparatingElements(beamElement, polygonColor, noteheadColor, stemColor, accidColor, dotsColor) {
  const notes = beamElement.querySelectorAll('.note');

  for (const note of notes) {
    paintNoteParts(note, noteheadColor, stemColor, accidColor, dotsColor); // Cambiar el color del accidente a negro
  }

  const polygons = beamElement.querySelectorAll('polygon');
  for (const polygon of polygons) {
    polygon.style.fill = polygonColor;
  }

  const stem = beamElement.querySelector('.stem');
  if (stem) {
    paintStem(stem, stemColor);
  }
}

const allBeams = document.querySelectorAll('g.beam');
for (const beam of allBeams) {
  console.log(beam);
  paintBeamSeparatingElements(beam, 'red', 'green', 'red', 'blue', 'cyan');
}
######################################################

############## CHORD Uniform ##############
function paintChordUniform(chordElement, chordColor) {
  chordElement.style.fill = chordColor;

  const stem = chordElement.querySelector('.stem');
  if (stem) {
    paintStem(stem, chordColor);
  }
}

const allChords = document.querySelectorAll('g.chord');
for (const chord of allChords) {
  console.log(chord);
  paintChordUniform(chord, 'red');
}
###########################################

############## CHORD Separating Elements ##############
function paintChordSeparatingElements(chordElement, noteheadColor, stemColor, accidColor, dotsColor) {
  const notes = chordElement.querySelectorAll('.note');

  for (const note of notes) {
    paintNoteParts(note, noteheadColor, stemColor, accidColor, dotsColor); // Cambiar el color del accidente a negro
  }

  const stem = chordElement.querySelector('.stem');
  if (stem) {
    paintStem(stem, stemColor);
  }
}

const allChords = document.querySelectorAll('g.chord');
for (const chord of allChords) {
  console.log(chord);
  paintChordSeparatingElements(chord, 'green', 'red', 'blue', 'cyan');
}
########################################################
-->

<!--
FUNCIONES PARA PINTAR LOS DIFERENTES ELEMENTOS INDIVIDUALES (NOTES, RESTS)

############## NOTES (Pintando Stem tambien (palo de la nota)) ##############
function paintNoteParts(noteElement, noteheadColor, stemColor, accidColor, dotsColor) {
  const notehead = noteElement.querySelector('.notehead');
  const stem = noteElement.querySelector('.stem');
  const accid = noteElement.querySelector('.accid');
  const dots = noteElement.querySelector('.dots');

  if (notehead) {
    notehead.style.fill = noteheadColor;
  }
  if (stem) {
    paintStem(stem, stemColor);
  }
  if (accid) {
    accid.style.fill = accidColor;
  }
  if (dots) {
    dots.style.fill = dotsColor;
  }
}

const allNotes = document.querySelectorAll('g.note');
for (const note of allNotes) {
  console.log(note);
  paintNoteParts(note, 'yellow', 'red', 'pink', 'purple'); // O usa la configuración que desees
}
#############################################################################

############## STEM (Palos de Notas) ##############
function paintStem(stemElement, stemColor) {
    const path = stemElement.querySelector('path');
    if (path) {
        path.style.stroke = stemColor;
    }
}
####################################################

############## REST (Silencios) ##############
const allRests = document.querySelectorAll('g.rest');
for (const rest of allRests) {
  console.log(rest);
  rest.style.fill = 'brown'
}
###############################################

############## CLEF (Claves (de Sol, Fa, Do...)) ##############
const allClefs = document.querySelectorAll('g.clef');
for (const clef of allClefs) {
  console.log(clef);
  clef.style.fill = 'red';
}
################################################################

const allMeters = document.querySelectorAll('g.meter');
for (const meter of allMeters) {
  console.log(meter);
  meter.style.fill = 'red';
}
-->

<!--
FUNCION PARA IR PINTANDO LOS ELEMENTOS CADA X TIEMPO

// Obtener todos los elementos SVG dentro del contenedor
let elements = document.querySelectorAll('g.note, g.rest, g.beam, g.chord'); // Ajusta el selector según la estructura de tu SVG

//let notes = document.querySelectorAll('g.note');
//for (let i = 0; i < notes.length; i++) {
//    notes[i].style.fill = 'red';
//}

let currentIndex = 0;

setInterval(function () {
  if (currentIndex < elements.length) {
    .log(elements[currentIndex]);
    // Cambiar el color a tu elección (por ejemplo, rojo)
    if(elements[currentIndex].classList.contains('note')) {
        elements[currentIndex].style.fill = 'blue';
    } else {
        elements[currentIndex].style.fill = 'green';
    }
    currentIndex++;
  }
}, 500);
-->



<!--            fetch(Android.getMeiXml(), {})-->
<!--                .then(response => response.arrayBuffer())-->
<!--                .then(data => {-->
<!--                    let svg = tk.loadZipDataBuffer(data);-->
<!--                    document.getElementById("notation").innerHTML = svg;-->

<!--                    let elements = document.querySelectorAll('g.notehead, g.stem, g.dots, g.accid, g.rest, polygon, g.clef, g.label, g.keySig, g.meterSig, g.dynam, g.dir, g.slur, g.labelAbbr, g.hairpin, g.grpSym');-->
<!--                    console.log("Número de elementos:", elements.length);-->

<!--                    elements.forEach((element, index) => {-->
<!--                        console.log(`Elemento ${index}:`, element);-->
<!--                    });-->
<!--                    let elements = document.querySelectorAll('g.notehead, g.stem, g.dots, g.accid, g.rest, polygon, g.clef, g.label, g.keySig, g.meterSig, g.dynam, g.dir, g.slur, g.labelAbbr, g.hairpin, g.grpSym');-->
<!--                    console.log("elementos", elements);-->

<!--                    elements.forEach((element, index) => {-->
<!--                      let hasSameId = notesWithoutFixId.some(item => {-->
<!--                        console.log('item id:', item.id);-->
<!--                        console.log('element id:', element.id);-->
<!--                        return item.id === element.id;-->
<!--                      });-->
<!--        -->
<!--                      const fixId = `${packageId}_${globalCounter}`;-->
<!--                      if (!hasSameId) {-->
<!--                        if (element.classList.contains('beam')) {-->
<!--                          setIdToBeamParts(element, fixId);-->
<!--                        } else {-->
<!--                          elementsWithoutFixId.push(element);-->
<!--                          if(element.classList.contains('accid')) {-->
<!--                             if(element.querySelectorAll('use') == null) {-->
<!--                             } else {-->
<!--                                element.setAttribute('fixId', fixId);-->
<!--                             }-->
<!--                          } else {-->
<!--                             element.setAttribute('fixId', fixId);-->
<!--                          }-->
<!--                          globalCounter = globalCounter + 1;-->
<!--                        }-->
<!--                      }-->
<!--                    });-->
<!--        -->
<!--                    elements2 = Array.from(elements);-->
<!--        -->
<!--                    paintSavedIds(elements2);-->
<!--                })-->
<!--                .catch(e => {-->
<!--                    console.log(e);-->
<!--                });-->
