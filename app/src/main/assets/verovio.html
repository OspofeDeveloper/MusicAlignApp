<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
//--------------------------------------------------------------------------------------------------
// Global variables
//--------------------------------------------------------------------------------------------------
     let fixIdSeparator = "%";
     let globalCounter = 0;
     let elementsWithoutFixId = [];
     let notesWithoutFixId = [];
     let intervalId = null;
     let objectsList = null;
     let currentIndex = parseInt(getCurrentIndexFromAndroid().split(fixIdSeparator)[1]);
     let elementsIdsJson = getListElementsFromAndroid();
     let elementsIds = JSON.parse(elementsIdsJson);
     let packageId = getFileIdFromAndroid();
     let highestElement = getHighestElementIdFromAndroid();
     let highestElementIndex = highestElement.split(fixIdSeparator)[1];

//--------------------------------------------------------------------------------------------------
// Android related functions
//--------------------------------------------------------------------------------------------------
     function getSVGFromAndroid() { return Android.getSVGFile(); }
     function getCurrentIndexFromAndroid() { return Android.getLastElementId(); }
     function getListElementsFromAndroid() { return Android.getListElements(); }
     function getFileIdFromAndroid() { return Android.getFileId(); }
     function getHighestElementIdFromAndroid() { return Android.getHighestElementId(); }
     function sendFinalElementIndexToAndroid(index) { Android.sendFinalElementNum(index); }
     function sendLastElementIdToAndroid(id) { Android.sendLastElementId(id); }
     function sendNextElementIdToAndroid(id, type) { Android.sendNextElementId(id, type); }
     function sendNextElementIdFromPlayToAndroid(id, type) { Android.sendNextFromPlay(id, type); }
     function sendAlignedElementIdToAndroid(id, nextId, type) { Android.sendAlignedElementId(id, nextId, type); }
     function sendHighestElementIdToAndroid(id) { Android.sendHighestElementId(id); }
     function sendEndOfListReachedToAndroid(isEnd) { Android.sendEndOfListReached(isEnd); }

//--------------------------------------------------------------------------------------------------
// Main function for rendering the SVG
//--------------------------------------------------------------------------------------------------
     const filePath = getSVGFromAndroid();
     console.log('URL del archivo:', filePath);

     document.addEventListener("DOMContentLoaded", () => {
         fetch(filePath)
             .then(response => response.text())
             .then(svgContent => {
                 document.getElementById("notation").innerHTML = svgContent;
                 const svgElement = document.querySelector('#notation svg');
                 svgElement.style.transform = 'scale(0.9)';

                 let objectsSupported = [
                    'g.stem', 'g.notehead', 'g.accid', 'g.keyAccid', 'g.barLine', 'g.clef',
                    'g.flag', 'g.rest', 'g.mRest', 'g.tie', 'g.meterSig', 'g.tupletNum',
                    'polygon.beam', 'g.tupletBracket', 'g.multiRest', 'g.octave', 'g.fermata',
                    'g.artic', 'g.trill', 'ellipse.single_dot', 'use.bTrem_line', 'polygon.fTrem_line',
                    'g.mRpt', 'g.hairpin', 'g.slur', 'g.glissando', 'g.mordent', 'g.segno', 'g.dynam',
                    'g.coda', 'g.caesura', 'g.turn', 'g.bracketSpan'
                 ]
                 let svgObjects = document.querySelectorAll(objectsSupported);

                 svgObjects.forEach(object => {
<!--                     newColorObjects(object, 'red');-->
                     setFixIdToObjects(object);
                     console.log(object.getAttribute('fixId'), object.getAttribute('id'), object.getAttribute('class'));
                 });

                 sendFinalElementIndexToAndroid(svgObjects.length.toString());
                 console.log("NÃºmero de elementos:", svgObjects.length);

                 objectsList = Array.from(svgObjects).filter(object => object.getAttribute('fixId'));
                 initSystem();
               }
             ).catch(error => {
                 console.error("Error al cargar el SVG:", error);
             });
     });

//----------------------------------------------------------------------------------------------------
// Functions for controlling the SVG from the app
//----------------------------------------------------------------------------------------------------
     function initSystem() {
         newColorObjects(objectsList[currentIndex], 'blue');
         sendLastElementIdToAndroid(objectsList[currentIndex].getAttribute('fixId'));
         sendNextElementIdToAndroid(objectsList[currentIndex].getAttribute('fixId'), "initSystem");
     }

     function initNextAlignment() {
         colorNextObject("nextFromAlignment");
     }

     function initNext() {
         colorNextObject("nextFromButton");
     }

     function initBack() {
         if (currentIndex > 0) {
            let currentObject = objectsList[currentIndex];
            if(elementsIds.includes(currentObject.getAttribute('fixId'))) {
                prepareForColoringObjects(currentObject, 'green');
            } else {
                prepareForColoringObjects(currentObject, 'orange');
            }

            currentIndex--;
            sendNextElementIdToAndroid(objectsList[currentIndex].getAttribute('fixId'), "back");
            if (currentIndex >= 0) {
                let newCurrentObject = objectsList[currentIndex];
                prepareForColoringObjects(newCurrentObject, 'blue');
            }
        }
     }

     function initBackNotAligned() {
         for (let i = currentIndex - 1; i >= 0; i--) {
            const currentObject = objectsList[i];
            const currentFixId = currentObject.getAttribute('fixId');

            if (!elementsIds.includes(currentFixId)) {
                const currentObjectFixId = objectsList[currentIndex].getAttribute('fixId');
                const color = elementsIds.includes(currentObjectFixId) ? 'green' : 'orange';

                prepareForColoringObjects(objectsList[currentIndex], color);
                currentIndex = i;
                sendNextElementIdToAndroid(currentFixId, "notAligned");
                prepareForColoringObjects(currentObject, 'blue');
                return;
            }
        }
     }

     function initNextNotAligned() {
        if (currentIndex >= objectsList.length - 1) return;

        for (let i = currentIndex + 1; i < objectsList.length; i++) {
            const currentObject = objectsList[i];
            const currentFixId = currentObject.getAttribute('fixId');

            if (!elementsIds.includes(currentFixId)) {
                const currentObjectFixId = objectsList[currentIndex].getAttribute('fixId');
                const color = elementsIds.includes(currentObjectFixId) ? 'green' : 'orange';

                prepareForColoringObjects(objectsList[currentIndex], color);
                currentIndex = i;
                sendNextElementIdToAndroid(currentFixId, "notAligned");
                prepareForColoringObjects(currentObject, 'blue');
                return;
            }
        }
     }

     function prepareForRealignment() {
         let currentObjectFixId = objectsList[currentIndex].getAttribute('fixId')
         let currentObjectIndex = elementsIds.indexOf(currentObjectFixId);

         if (currentObjectIndex !== -1) {
             elementsIds.splice(currentObjectIndex, 1);
         }
     }

     let paintIndex = 0;
     let objectsColors = [];

     function playAutoMode() {
         paintIndex = currentIndex;

         objectsList.forEach(object => {
             objectsColors.push(object.style.fill);
         });

         colorNextObjectPlay(objectsList, paintIndex);
         paintIndex++;

         intervalId = setInterval(() => {
             if(paintIndex > 0) {
                 colorPreviousObjectPlay(objectsList, paintIndex - 1, objectsColors[paintIndex - 1]);
             }

             colorNextObjectPlay(objectsList, paintIndex);

             let currentObject = objectsList[currentIndex];
             prepareForColoringObjects(currentObject, 'green');

             paintIndex++;
             if(paintIndex >= objectsList.length) {
                 clearInterval(intervalId);
             }

             sendNextElementIdFromPlayToAndroid(objectsList[paintIndex-1].getAttribute('fixId'),"nextFromPlay");
         }, 1500);
     }

     function stopAutoMode() {
         colorPreviousObjectPlay(objectsList, paintIndex-1, objectsColors[paintIndex-1]);
         clearInterval(intervalId);
         currentIndex = paintIndex - 2;
         colorNextObject("nextFromButton")
     }

//----------------------------------------------------------------------------------------------------
// Functions for setting the fixId to beam parts
//----------------------------------------------------------------------------------------------------
     function setFixIdToObjects(object) {
        if (!object.hasAttribute('visibility') || object.getAttribute('visibility') !== 'hidden') {
            const fixId = `${packageId}${fixIdSeparator}${globalCounter}`;
            object.setAttribute('fixId', fixId);
            globalCounter++;
        }
     }

     function setIdToBeamParts(beamElement, fixId) {
        elementsWithoutFixId.push(beamElement);
        const polygons = beamElement.querySelectorAll('polygon');
        for (const polygonElement of polygons) {
            polygonElement.setAttribute('fixId', globalCounter);
            globalCounter = globalCounter + 1;
            elementsWithoutFixId.push(polygonElement);
        }
     }

     function sendPolygonsId(beamElement, type) {
        const polygons = beamElement.querySelectorAll('polygon');
        for (const polygonElement of polygons) {
            if(polygonElement.getAttribute('fixId') === currentIndex) {
                sendNextElementIdToAndroid(polygonElement.getAttribute('fixId'), type);
            }
        }
     }

     function setElementAligned(elemento, nextElement, type) {
         elementsIds.push(elemento.toString());
         sendAlignedElementIdToAndroid(elemento, nextElement, type);
     }

//--------------------------------------------------------------------------------------------------
// Auxiliary functions for coloring elements depending on App actions
//--------------------------------------------------------------------------------------------------
     function colorNextObjectPlay(elements, index) {
        prepareForColoringObjects(elements[index], 'blue');
     }

     function colorPreviousObjectPlay(elements, index, color) {
        prepareForColoringObjects(elements[index], color);
     }

     function colorNextObject(type) {
        if (currentIndex < objectsList.length) {
            let firstObject = "0";
            let nextObject = "0";

            if(currentIndex == 0) {
                objectsList.forEach((object, index) => {
                    if(index == 0) {
                        firstObject = object;
                    }
                    if(index == 1) {
                        nextObject = object;
                    }
                });
            } else {
                firstObject = objectsList[currentIndex];
                if(currentIndex <= objectsList.length) {
                    nextObject = objectsList[currentIndex + 1];
                }
            }

            switch (type) {
                case "nextFromAlignment":
                    colorNextFromAlignment(firstObject, nextObject, type);
                    break;
                case "nextFromButton":
                    colorNextFromButton(firstObject, nextObject);
                    break;
            }

            currentIndex = (currentIndex === (objectsList.length - 1)) ? currentIndex : currentIndex + 1;
            if (currentIndex < objectsList.length) {
                let currentObject = objectsList[currentIndex];
                prepareForColoringObjects(currentObject, 'blue');
                if(type === "nextFromButton") {
                    if (currentObject.classList.contains('beam')) {
                        sendPolygonsId(currentObject, type);
                    } else {
                        sendNextElementIdToAndroid(currentObject.getAttribute('fixId'), type);
                    }
                }
            }
        }
     }

     function colorNextFromAlignment(firstObject, nextObject, type) {
        if(currentIndex < objectsList.length - 1) {
            setElementAligned(firstObject.getAttribute('fixId'), nextObject.getAttribute('fixId'), type);
            prepareForColoringObjects(firstObject, 'green');
        } else if (currentIndex === objectsList.length - 1) {
            setElementAligned(firstObject.getAttribute('fixId'), firstObject.getAttribute('fixId'), type);
        }
     }

     function colorNextFromButton(firstObject, nextObject) {
        if(elementsIds.includes(firstObject.getAttribute('fixId'))) {
            prepareForColoringObjects(firstObject, 'green');
        } else {
            prepareForColoringObjects(firstObject, 'orange');
        }
     }

//--------------------------------------------------------------------------------------------------
// Auxiliary functions for coloring svg objects depending on the object
//--------------------------------------------------------------------------------------------------
   function prepareForColoringObjects(objectToPaint, color) {
       sendLastElementIdToAndroid(objectsList[currentIndex].getAttribute('fixId'));
       if(currentIndex >= highestElementIndex) {
           highestElementIndex = currentIndex;
       }

       sendHighestElementIdToAndroid(objectsList[highestElementIndex].getAttribute('fixId'));
       if(currentIndex >= objectsList.length - 1) {
           sendEndOfListReachedToAndroid(true);
       } else {
           sendEndOfListReachedToAndroid(false);
       }

       newColorObjects(objectToPaint, color);
   }

   function newColorObjects(object, color) {
       switch (true) {
            case object.classList.contains('stem'):
               paintStem(object, color);
               break;
            case object.classList.contains('notehead'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('accid'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('keyAccid'):
                paintStandardObject(object, color);
                break;
            case object.classList.contains('barLine'):
                paintBarLine(object, color);
                break;
            case object.classList.contains('clef'):
                paintStandardObject(object, color);
                break;
            case object.classList.contains('flag'):
                paintStandardObject(object, color);
                break;
            case object.classList.contains('rest'):
                paintStandardObject(object, color);
                break;
            case object.classList.contains('mRest'):
                paintStandardObject(object, color);
                break;
            case object.classList.contains('tie'):
                paintTie(object, color);
                break;
            case object.classList.contains('meterSig'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('tupletNum'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('beam'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('tupletBracket'):
               paintTupletBracket(object, color);
               break;
            case object.classList.contains('multiRest'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('octave'):
               paintOctave(object, color);
               break;
            case object.classList.contains('fermata'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('artic'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('trill'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('single_dot'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('bTrem_line'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('fTrem_line'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('mRpt'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('hairpin'):
               paintHairpin(object, color);
               break;
            case object.classList.contains('slur'):
               paintSlur(object, color);
               break;
            case object.classList.contains('glissando'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('mordent'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('segno'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('dynam'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('coda'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('caesura'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('turn'):
               paintStandardObject(object, color);
               break;
            case object.classList.contains('bracketSpan'):
               paintBracketSpan(object, color);
               break;
            default: break;
       }
   }

   function paintStandardObject(standardObject, color) {
       standardObject.style.fill = color;
   }

   <!--                 paintSavedIds(objectsList);-->

<!--                 function paintSavedIds(objectsList) {-->
<!--                    let paintedIds = [];-->

<!--                    elementsIds.forEach(elementId => {-->
<!--                        objectsList.forEach(element => {-->
<!--                            if (element.getAttribute('fixId') === elementId) {-->
<!--                                prepareForColoringObjects(element, 'green');-->
<!--                                paintedIds.push(elementId); // Agregar el fixId del elemento pintado a la lista-->
<!--                            }-->
<!--                        });-->
<!--                    });-->

<!--                    let unpaintedIds = [];-->

<!--                    objectsList.forEach(element => {-->
<!--                        let elementId = element.getAttribute('fixId');-->
<!--                        if (!paintedIds.includes(elementId)) {-->
<!--                            unpaintedIds.push(elementId.split(fixIdSeparator)[1]);-->
<!--                        }-->
<!--                    });-->

<!--                    unpaintedIds.forEach(unpaintedElementIndex => {-->
<!--                        if (parseInt(element) <= highestElementIndex) {-->
<!--                            prepareForColoringObjects(objectsList[unpaintedElementIndex], 'orange');-->
<!--                        }-->
<!--                    });-->

<!--                    prepareForColoringObjects(objectsList[currentIndex], 'blue');-->
<!--                 }-->

//--------------------------------------------------------------------------------------------------
// Functions for painting stems
//--------------------------------------------------------------------------------------------------
     function paintStem(stem, color) {
         const path = stem.querySelector('path');
         if (path) {
             path.style.stroke = color;
             stem.style.fill = color;
         }
     }

//--------------------------------------------------------------------------------------------------
// Functions for painting ties
//--------------------------------------------------------------------------------------------------
     function paintTie(tie, color) {
        tie.style.fill = color;
        const paths = tie.querySelectorAll('path');
        for (const path of paths) {
            path.style.stroke = color;
        }
     }

//--------------------------------------------------------------------------------------------------
// Functions for painting tupleBrackets
//--------------------------------------------------------------------------------------------------
     function paintTupletBracket(tupletBracket, color) {
        const polylines = tupletBracket.querySelectorAll('polyline');
        for (const polyline of polylines) {
            polyline.style.stroke = color;
        }
     }

//--------------------------------------------------------------------------------------------------
// Functions for painting octave
//--------------------------------------------------------------------------------------------------
     function paintOctave(octave, color) {
        octave.style.fill = color;
        const polylines = octave.querySelectorAll('polyline');
        const paths = octave.querySelectorAll('path');

        for (const polyline of polylines) {
            polyline.style.stroke = color;
        }

        for (const path of paths) {
            path.style.stroke = color;
        }
     }

//--------------------------------------------------------------------------------------------------
// Functions for painting hairpin
//--------------------------------------------------------------------------------------------------
     function paintHairpin(hairpin, color) {
        const polylines = hairpin.querySelectorAll('polyline');

        for (const polyline of polylines) {
            polyline.style.stroke = color;
        }
     }

//--------------------------------------------------------------------------------------------------
// Functions for painting slurs
//--------------------------------------------------------------------------------------------------
     function paintSlur(slur, color) {
        slur.style.fill = color;
        const paths = slur.querySelectorAll('path');

        for (const path of paths) {
            path.style.stroke = color;
        }
     }

//--------------------------------------------------------------------------------------------------
// Functions for painting barLines
//--------------------------------------------------------------------------------------------------
     function paintBarLine(barLine, color) {
        const paths = barLine.querySelectorAll('path');
        const uses = barLine.querySelectorAll('use');

        for (const path of paths) {
            path.style.stroke = color;
        }

        for (const use of uses) {
            use.style.fill = color;
        }
     }

//--------------------------------------------------------------------------------------------------
// Functions for painting bracketSpans
//--------------------------------------------------------------------------------------------------
     function paintBracketSpan(bracketSpan, color) {
        const paths = bracketSpan.querySelectorAll('path');
        for (const path of paths) {
            path.style.stroke = color;
        }
     }

    </script>
    <script src="https://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js" defer></script>
</head>
<body>
<div id="notation"></div>
</body>
</html>
